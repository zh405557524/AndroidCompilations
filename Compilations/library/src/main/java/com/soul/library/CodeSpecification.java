package com.soul.library;

/**
 * * @author soul
 *
 * @项目名:Compilations
 * @包名: com.soul.library
 * @作者：祝明
 * @描述：代码规范说明
 * @创建时间：2017/1/6 14:47
 */
public class CodeSpecification {

    /**3.4 类声明
     *
     *3.4.1 只有一个顶级
     *类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。
     *例外：package-info.java，该文件中可没有package-info类。
     *
     *3.4.2 类成员顺序
     *类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。
     *最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。
     *比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。
     *
     * 3.4.2.1 区块划分
     *建议使用注释将源文件分为明显的区块，区块划分如下
     *
     * 1 常量声明区
     * 2 UI控件成员变量声明区
     * 3 普通成员变量声明区
     * 4 内部接口声明区
     * 5 初始化相关方法区
     * 6 事件响应方法区
     * 7 普通逻辑方法区
     * 8 重载的逻辑方法区
     * 9 发起异步任务方法区
     * 10 异步任务回调方法区
     * 11 生命周期回调方法区(除去onCreate()方法)
     * 12 内部类声明区

     * 3.4.2.2 类成员排列通用规则
     * 1 按照发生的先后顺序排序
     * 2 常量按照使用先后排序
     * 3 UI控件成员变量按照layout文件中的先后顺序排序
     * 4 普通成员变量按照使用的先后顺序排列
     * 5 方法基本上按照使用的先后顺序在各自区块中排序
     * 6 相关功能作为小区块放在一起(或者封装掉)

     *
     * 3.4.2.3 重载：永不分离
     *当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。
     */


    /**4. 格式术语
     *
     * 4.1 大括号
     *4.1.1 使用大括号(即使是可选的)
     *大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。
     *
     *4.1.3 空块：可以用简洁版本
     *一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。
     *
     * 4.2 块缩进：4个空格
     *每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。
     * (见4.1.2节中的代码示例)
     *
     * 4.3 一行一个语句
     *每个语句后要换行。
     *
     * 4.4 列限制：80或100
     *一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动
     * 换行。
     *
     * 4.5 自动换行
     *术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行
     *      (line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同
     *          一段代码会有好几种有效的自动换行方式。
     *
     * 4.5.1 从哪里断开
     *自动换行的基本准则是：更倾向于在更高的语法级别处断开。
     *
     * 4.5.2 自动换行时缩进至少+8个空格
     *自动换行时，第一行后的每一行至少比第一行多缩进8个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动
     *          换行时，缩进可能会多缩进不只8个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当
     *                  且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来
     *                          对齐前面行的符号。
     *
     * 4.6 空白
     *4.6.1 垂直空白
     *以下情况需要使用一个空行：

     *1 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。 例外： 两个连续字段之间
     * 的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
     *2 在函数体内，语句的逻辑分组间使用空行。
     *3 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
     *4 要满足本文档中其他节的空行要求(比如3.3节：import语句)
     *5多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。
     *
     * 4.6.2 水平空白
     *除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：
     *1分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。
     *2分隔任何保留字与其前面的右大括号(})(如else, catch)。
     *3在任何左大括号前({)，两个例外：
     *      o @SomeAnnotation({a, b})(不使用空格)。
     *      o String[][] x = foo;(大括号间没有空格，见下面的Note)。
     *4在任何二元或三元运算符的两侧。这也适用于以下"类运算符"符号：
     *      o 类型界限中的&()。
     *      o catch块中的管道符号(catch (FooException | BarException e)。
     *      o foreach语句中的分号。
     *5在, : ;及右括号())后
     *6如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。
     *7类型和变量之间：List list。
     *8数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。
     *
     * 4.6.3 水平对齐：不做要求
     *
     */

    /**4.7 用小括号来限定组：推荐
     *
     */

    /**
     * 4.8 具体结构
     * 4.8.1 枚举类
     * 枚举常量间用逗号隔开，换行可选。
     * 没有方法和文档的枚举类可写成数组初始化的格式：
     * <p>
     * 4.8.2 变量声明
     * 4.8.2.1 每次只声明一个变量
     * 不要使用组合声明，比如int a, b;。
     * 4.8.2.2 需要时才声明，并尽快进行初始化
     * 不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变
     * 量在声明时最好就进行初始化，或者声明后尽快进行初始化。
     * <p>
     * 4.8.3 数组
     * 4.8.3.1 数组初始化：可写成块状结构
     * new int[] {
     * 0, 1, 2, 3
     * }
     * new int[] {
     * 0,
     * 1,
     * 2,
     * 3
     * }
     * new int[] {
     * 0, 1,
     * 2, 3
     * }
     * new int[]
     * {0, 1, 2, 3}
     * <p>
     * 4.8.3.2 非C风格的数组声明
     * 中括号是类型的一部分：String[] args， 而非 String args[]。
     * 4.8.4 switch语句
     * 术语说明：switch块的大括号内是一个或多个语句组。
     * 每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。
     * 4.8.4.1 缩进
     * 与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。
     * 4.8.4.2 Fall-through：注释
     * 在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。
     * 示例：
     * switch (input) {
     * case 1:
     * case 2:
     * prepareOneOrTwo();        // fall through
     * case 3:
     * handleOneTwoOrThree();
     * break;
     * default:
     * handleLargeNumber(input);
     * }
     * <p>
     * <p>
     * <p>
     * 搜索
     * Android 编码规范
     * 175b7d6fe557  作者 diygreen 关注
     * 2016.04.03 11:49 字数 8934 阅读 11639 评论 9 喜欢 131
     * 作者：李旺成
     * <p>
     * 时间：2016年4月3日
     * <p>
     * 1. 前言
     * 这份文档参考了 Google Java 编程风格规范和 Google 官方 Android 编码风格规范。该文档仅供参考，只要形成一个统一的风格，见量知其意就可。
     * <p>
     * 1.1 术语说明
     * 在本文档中，除非另有说明：
     * <p>
     * 术语 class 可表示一个普通类，枚举类，接口或是annotation类型(@interface)
     * 术语 comment 只用来指代实现的注释(implementation comments)，我们不使用"documentation comments"一词，而是用 Javadoc。其他的术语说明会偶尔在后面的文档出现。
     * 1.2 指南说明本文档中的示例代码并不作为规范，仅供参考。
     * 基本格式方面使用 AndroidStudio 默认模板即可（使用格式化快捷键处理后基本符合）。
     * <p>
     * 2. 源文件基础
     * 2.1 文件名
     * 源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。
     * <p>
     * 2.2 文件编码：UTF-8
     * 源文件编码格式为 UTF-8。
     * <p>
     * 2.3 特殊字符
     * 2.3.1 空白字符
     * 除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：
     * <p>
     * 所有其它字符串中的空白字符都要进行转义。
     * 制表符不用于缩进（可以在IDE中Tab键设置为若干个空格）。
     * 2.3.2 特殊转义序列
     * 对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \", \'及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。
     * <p>
     * 2.3.3 非ASCII字符
     * 对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。
     * <p>
     * Tip:在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。
     * 例如：
     * String unitAbbrev = "μs"; | 赞，即使没有注释也非常清晰
     * String unitAbbrev = "\u03bcs"; // "μs" | 允许，但没有理由要这样做
     * String unitAbbrev = "\u03bcs"; // Greek letter mu, "s" | 允许，但这样做显得笨拙还容易出错
     * String unitAbbrev = "\u03bcs"; | 很糟，读者根本看不出这是什么
     * return '\ufeff' + content; // byte order mark | Good，对于非打印字符，使用转义，并在必要时写上注释
     * <p>
     * Tip:永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)
     * 3. 源文件结构
     * 一个源文件包含(按顺序地)：
     * <p>
     * 许可证或版权信息(如有需要)
     * package语句
     * import语句
     * 一个顶级类(只有一个)以上每个部分之间用一个空行隔开。
     * 3.1 许可证或版权信息
     * 如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。
     * <p>
     * 3.2 package语句
     * package 语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)
     * <p>
     * 3.3 import语句
     * 3.3.1 import不要使用通配符
     * 即，不要出现类似这样的import语句：import java.util.*;
     * <p>
     * 3.3.2 不要换行
     * import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)
     * <p>
     * 3.3.3 顺序和间距
     * import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：
     * <p>
     * 所有的静态导入独立成组
     * com.google imports(仅当这个源文件是在com.google包下)
     * 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun
     * java imports5.javax imports组内不空行，按字典序排列。
     * 3.4 类声明
     * 3.4.1 只有一个顶级
     * 类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。
     * 例外：package-info.java，该文件中可没有package-info类。
     * <p>
     * 3.4.2 类成员顺序
     * 类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。
     * 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。
     * <p>
     * 3.4.2.1 区块划分
     * <p>
     * 建议使用注释将源文件分为明显的区块，区块划分如下
     * <p>
     * 常量声明区
     * UI控件成员变量声明区
     * 普通成员变量声明区
     * 内部接口声明区
     * 初始化相关方法区
     * 事件响应方法区
     * 普通逻辑方法区
     * 重载的逻辑方法区
     * 发起异步任务方法区
     * 异步任务回调方法区
     * 生命周期回调方法区（出去onCreate()方法）
     * 内部类声明区
     * 3.4.2.2 类成员排列通用规则
     * <p>
     * 按照发生的先后顺序排列
     * 常量按照使用先后排列
     * UI控件成员变量按照layout文件中的先后顺序排列
     * 普通成员变量按照使用的先后顺序排列
     * 方法基本上都按照调用的先后顺序在各自区块中排列
     * 相关功能作为小区块放在一起（或者封装掉）
     * 3.4.2.3 重载：永不分离
     * <p>
     * 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。
     * <p>
     * 4. 格式术语
     * 说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。
     * <p>
     * 4.1 大括号
     * 4.1.1 使用大括号(即使是可选的)
     * 大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。
     * <p>
     * 4.1.2 非空块：K & R 风格
     * 对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (Egyptian brackets):
     * <p>
     * 左大括号前不换行
     * 左大括号后换行
     * 右大括号前换行
     * 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。
     * 例如，如果右大括号后面是else或逗号，则不换行。
     * 示例：
     * <p>
     * return new MyClass() {
     *
     * @Override public void method() {
     * if (condition()) {
     * try {
     * something();
     * } catch (ProblemException e) {
     * recover();
     * }
     * }
     * }
     * };
     * 4.8.1节给出了enum类的一些例外。
     * <p>
     * 4.1.3 空块：可以用简洁版本
     * 一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。
     * 例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要
     * 换行。
     * 示例：
     * <p>
     * void doNothing() {}
     * 4.2 块缩进：4个空格
     * 每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。
     * (见4.1.2节中的代码示例)
     * <p>
     * 4.3 一行一个语句
     * 每个语句后要换行。
     * <p>
     * 4.4 列限制：80或100
     * 一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须
     * 自动换行。
     * 例外：
     * <p>
     * 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。
     * package和import语句(见3.2节和3.3节)。
     * 注释中那些可能被剪切并粘贴到shell中的命令行。
     * 4.5 自动换行
     * 术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行
     * (line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代
     * 码会有好几种有效的自动换行方式。
     * <p>
     * Tip:提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)
     * 4.5.1 从哪里断开
     * 自动换行的基本准则是：更倾向于在更高的语法级别处断开。
     * <p>
     * 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google
     * 其它语言的编程风格不同(如 C++ 和 JavaScript )。
     * 这条规则也适用于以下"类运算符"符号：点分隔符(.)，类型界限中的 &（)，catch 块中的管道符号
     * (catch (FooException | BarException e)
     * 如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于
     * foreach语句中的分号。
     * 方法名或构造函数名与左括号留在同一行。
     * 逗号(,)与其前面的内容留在同一行。
     * 4.5.2 自动换行时缩进至少+8个空格
     * 自动换行时，第一行后的每一行至少比第一行多缩进8个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自
     * 动换行时，缩进可能会多缩进不只8个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它
     * 们开始于同级语法元素。
     * 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。
     * <p>
     * 4.6 空白
     * 4.6.1 垂直空白
     * 以下情况需要使用一个空行：
     * <p>
     * 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。 例外： 两个连续字段之间
     * 的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
     * 在函数体内，语句的逻辑分组间使用空行。
     * 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
     * 要满足本文档中其他节的空行要求(比如3.3节：import语句)
     * 多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。
     * 4.6.2 水平空白
     * 除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：
     * <p>
     * 分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。
     * 分隔任何保留字与其前面的右大括号(})(如else, catch)。
     * 在任何左大括号前({)，两个例外：
     * o @SomeAnnotation({a, b})(不使用空格)。
     * o String[][] x = foo;(大括号间没有空格，见下面的Note)。
     * 在任何二元或三元运算符的两侧。这也适用于以下"类运算符"符号：
     * o 类型界限中的&()。
     * o catch块中的管道符号(catch (FooException | BarException e)。
     * o foreach语句中的分号。
     * 在, : ;及右括号())后
     * 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。
     * 类型和变量之间：List list。
     * 数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。
     * Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。
     * 4.6.3 水平对齐：不做要求
     * 术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。
     * 这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的
     * 代码，我们也不需要去保持这种风格。
     * 以下示例先展示未对齐的代码，然后是对齐的代码：
     * <p>
     * private int x; // this is fine
     * private Color color; // this too
     * <p>
     * private int    x;         // permitted, but future edits
     * private Color  color;     // may leave it unaligned
     * Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。
     * 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如
     * 程序员想保持这种水平对齐的风格)。
     * 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。
     * 4.7 用小括号来限定组：推荐
     * 除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该
     * 去掉小括号。
     * 我们没有理由假设读者能记住整个Java运算符优先级表。
     * <p>
     * 4.8 具体结构
     * 4.8.1 枚举类
     * 枚举常量间用逗号隔开，换行可选。
     * 没有方法和文档的枚举类可写成数组初始化的格式：
     * <p>
     * private enum Suit {
     * CLUBS,
     * HEARTS,
     * SPADES,
     * DIAMONDS
     * }
     * 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。
     * <p>
     * 4.8.2 变量声明
     * 4.8.2.1 每次只声明一个变量
     * <p>
     * 不要使用组合声明，比如int a, b;。
     * <p>
     * 4.8.2.2 需要时才声明，并尽快进行初始化
     * <p>
     * 不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部
     * 变量在声明时最好就进行初始化，或者声明后尽快进行初始化。
     * <p>
     * 4.8.3 数组
     * 4.8.3.1 数组初始化：可写成块状结构
     * <p>
     * 数组初始化可以写成块状结构，比如，下面的写法都是OK的：
     * <p>
     * new int[] {
     * 0, 1, 2, 3
     * }
     * new int[] {
     * 0,
     * 1,
     * 2,
     * 3
     * }
     * new int[] {
     * 0, 1,
     * 2, 3
     * }
     * new int[]
     * {0, 1, 2, 3}
     * 4.8.3.2 非C风格的数组声明
     * <p>
     * 中括号是类型的一部分：String[] args， 而非 String args[]。
     * <p>
     * 4.8.4 switch语句
     * 术语说明：switch块的大括号内是一个或多个语句组。
     * 每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。
     * <p>
     * 4.8.4.1 缩进
     * <p>
     * 与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多
     * 条语句。
     * <p>
     * 4.8.4.2 Fall-through：注释
     * <p>
     * 在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程
     * 序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注
     * 释并不需要在最后一个语句组(一般是default)中出现。
     * 示例：
     * <p>
     * switch (input) {
     * case 1:
     * case 2:
     * prepareOneOrTwo();        // fall through
     * case 3:
     * handleOneTwoOrThree();
     * break;
     * default:
     * handleLargeNumber(input);
     * }
     * 4.8.4.3 default的情况要写出来
     * <p>
     * 每个switch语句都包含一个default语句组，即使它什么代码也不包含。
     * <p>
     * 4.8.5 注解(Annotations)
     * 注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换
     * 行)，因此缩进级别不变。
     * 例如：
     * @Nullable public String getNameIfPresent() { ... }
     * 例外：单个的注解可以和签名的第一行出现在同一行。
     * 例如：
     * @Override public int hashCode() { ... }应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段
     * 出现在同一行。
     * 例如：
     * @Partial @Mock DataLoader loader;
     * 参数和局部变量注解没有特定规则。
     * <p>
     * 4.8.6 注释
     * <p>
     * 块注释与其周围的代码在同一缩进级别。它们可以是/ ... /风格，也可以是// ...风格。对于多行的/ ... /注释，
     * 后续行必须从开始， 并且与前一行的对齐。
     * 以下示例注释都是OK的。
     * 注释不要封闭在由星号或其它字符绘制的框架里。
     */
    private enum Suit {
        CLUBS,
        HEARTS,
        SPADES,
        DIAMONDS
    }






}
